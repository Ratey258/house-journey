# 《买房记》游戏事件系统优化开发文档

## 1. 项目背景

《买房记》是一款模拟经营类游戏，玩家通过商品交易赚取差价，最终积累足够资金购买理想房产。事件系统是游戏的重要组成部分，为玩家提供各种随机遭遇和决策选择，增加游戏的趣味性和不确定性。

## 2. 当前问题分析

经过代码审查和玩家反馈，我们发现当前事件系统存在以下主要问题：

1. **事件模板重复**：大量事件使用相似的标题、描述和选项结构，导致玩家体验单调
2. **事件效果重复**：许多事件具有相似的效果，如金钱变化、商品价格变化等，缺乏新鲜感
3. **缺乏事件分类系统**：事件虽有类型但缺少更细致的分类管理，不便于后期维护和扩展
4. **事件选项缺乏动态性**：大多数事件选项是静态定义的，缺乏根据玩家状态动态调整
5. **事件分布不均**：不同游戏阶段缺乏针对性的事件设计，使玩家体验断层

## 3. 优化目标

1. 减少事件内容的重复性，提高事件的多样性
2. 增强事件与玩家状态和游戏阶段的关联性
3. 提高事件系统的可维护性和扩展性
4. 改进事件选择算法，使事件分布更加合理
5. 增加事件连锁和分支系统，提供更丰富的叙事体验

## 3.1 原事件系统分析

通过代码分析，我们发现原事件系统已经具有事件链和分支故事的基本框架，但实现方式较为简单，存在一些局限性：

### 3.1.1 现有的事件链机制

1. **实现方式**：
   - 主要通过 `nextEvent` 属性实现事件链接，在事件选项效果中设置下一个要触发的事件ID
   - `EventSystem` 和 `EventStore` 中有检查和触发 `nextEvent` 的逻辑
   - 事件完成后会检查是否有 `nextEvent`，如有则将其加入待触发队列

2. **现有事件链案例**：
   - **教程序列**：`tutorial_trading` → `tutorial_market` → `tutorial_goal`
   - **投资事件链**：`investment_opportunity` → `investment_result_big`/`investment_result_small`
   - **供应链事件**：`supply_chain_disruption` → `supply_chain_recovery`
   - **市场内幕事件**：`market_insider_info` → `insider_info_result`/`insider_info_result_small`

3. **房产相关事件链**：
   - **房产展览会系列**：`property_expo` → `property_expo_discover` → `property_investment_result` → `property_completion_notice` → `new_house_celebration`/`property_market_change`
   - **房产中介系列**：`property_broker_info` → `property_insider_tip` → `property_insider_result`/`property_missed_opportunity` → `property_new_opportunity` → `property_renovation_results` → `property_sale_result` → `property_price_negotiation`

### 3.1.2 现有的分支故事机制

1. **实现方式**：
   - 通过不同选项设置不同的 `nextEvent` 实现简单的分支
   - 部分事件根据玩家选择触发完全不同的后续事件
   - 没有专门的分支管理机制，仅通过硬编码实现

2. **分支示例**：
   - **投资分支**：`investment_opportunity` 根据玩家的投资金额大小，分别触发 `investment_result_big` 或 `investment_result_small`
   - **内幕消息分支**：`market_insider_info` 根据玩家选择，分别触发 `insider_info_result` 或 `insider_info_result_small`
   - **房产投资分支**：`property_insider_tip` 选择投资或观望，分别触发 `property_insider_result` 或 `property_missed_opportunity`

### 3.1.3 现有系统的局限性

1. **缺乏系统化管理**：
   - 事件链和分支全部通过硬编码定义，没有集中管理机制
   - 事件之间的关系不直观，需要仔细阅读代码才能理解完整的事件链

2. **分支结构局限**：
   - 分支逻辑简单，大多为二选一结构
   - 缺乏复杂的条件分支和多路径选择
   - 难以实现根据多个条件综合判断的复杂分支

3. **重复代码**：
   - 类似结构的事件链需要重复编写相似代码
   - 没有模板化系统减少代码重复

4. **扩展性差**：
   - 添加新的事件链或修改现有事件链需要修改多处代码
   - 缺乏可视化工具辅助设计复杂事件链

5. **地区特定事件的不足**：
   - 虽然有地点相关事件（如黑市突袭），但缺乏系统化的地区特性定义
   - 地区事件与玩家状态关联度低
   - 缺少根据地区特性动态生成事件的机制

## 4. 技术方案设计

### 4.1 事件模板系统

设计一个灵活的事件模板系统，允许根据参数快速生成不同变体的事件。

```javascript
// src/core/models/eventTemplates.js
export const EventTemplates = {
  // 市场价格变化模板
  MARKET_PRICE_CHANGE: {
    generateEvent: (category, modifier, isPositive = true) => {
      const id = `market_${category.toLowerCase()}_${isPositive ? 'boom' : 'crash'}_${Date.now()}`;
      const title = isPositive ? `${category}市场繁荣` : `${category}市场崩盘`;
      const description = isPositive ? 
        `${category}市场需求激增，价格大幅上涨！` : 
        `${category}市场供应过剩，价格大幅下跌！`;
      
      return createEvent(
        id,
        title,
        description,
        [
          createEventOption(
            '把握机会',
            isPositive ? '你抓住市场上涨机会，获得了额外收益。' : '你利用价格下跌，低价购入了一批商品。',
            createEventEffects({
              market: {
                categoryModifiers: {
                  [category]: modifier
                },
                duration: 2
              }
            })
          ),
          createEventOption(
            '观望市场',
            '你决定观望市场变化，不做任何行动。',
            createEventEffects({})
          )
        ],
        createEventConditions({
          probability: 0.2
        }),
        true,
        EventType.MARKET,
        1
      );
    }
  },
  
  // 财富意外变化模板
  FORTUNE_CHANGE: {
    generateEvent: (amount, isPositive = true) => {
      const id = `fortune_${isPositive ? 'gain' : 'loss'}_${Date.now()}`;
      const scenarios = isPositive ? 
        [
          { title: '意外之财', desc: '你在街上偶然发现了一个装满现金的钱包！' },
          { title: '远亲馈赠', desc: '一位远房亲戚给你寄来了一笔意外的礼金！' },
          { title: '投资回报', desc: '你之前的一笔小投资突然获得了丰厚回报！' }
        ] : 
        [
          { title: '意外支出', desc: '你的车子突然出现故障，需要一笔维修费。' },
          { title: '医疗账单', desc: '你突然生病，需要支付一笔医疗费用。' },
          { title: '设备损坏', desc: '你的电脑突然坏了，需要花钱维修。' }
        ];
      
      // 随机选择一个场景
      const scenario = scenarios[Math.floor(Math.random() * scenarios.length)];
      
      return createEvent(
        id,
        scenario.title,
        scenario.desc,
        [
          createEventOption(
            isPositive ? '欣然接受' : '支付费用',
            isPositive ? '你获得了一笔意外之财！' : '你不得不支付这笔费用。',
            createEventEffects({
              money: isPositive ? amount : -amount
            })
          )
        ],
        createEventConditions({
          probability: 0.15,
          // 如果是损失金钱，确保玩家有足够资金
          playerMoney: isPositive ? null : { min: amount }
        }),
        true,
        EventType.PERSONAL,
        1
      );
    }
  },
  
  // 背包容量变化模板
  CAPACITY_CHANGE: {
    generateEvent: (change, isPositive = true) => {
      const id = `capacity_${isPositive ? 'increase' : 'decrease'}_${Date.now()}`;
      const title = isPositive ? '背包升级机会' : '背包损坏';
      const description = isPositive ? 
        '你发现一个可以扩展存储空间的好机会。' : 
        '你的背包出现了一些问题，可能会影响存储空间。';
      
      const options = [];
      
      if (isPositive) {
        options.push(
          createEventOption(
            '购买升级',
            '你花费一些资金升级了背包容量。',
            createEventEffects({
              money: -change * 100, // 每单位容量花费100金钱
              capacity: change
            })
          ),
          createEventOption(
            '放弃机会',
            '你觉得当前容量足够用，决定节省这笔钱。',
            createEventEffects({})
          )
        );
      } else {
        options.push(
          createEventOption(
            '修复背包',
            '你花钱修复了背包，避免了容量损失。',
            createEventEffects({
              money: -change * 50 // 修复费用
            })
          ),
          createEventOption(
            '接受损失',
            '你决定接受背包容量的减少，省下修理费。',
            createEventEffects({
              capacity: -change
            })
          )
        );
      }
      
      return createEvent(
        id,
        title,
        description,
        options,
        createEventConditions({
          probability: 0.1,
          // 如果是背包损坏，确保玩家背包容量充足
          playerAttributes: isPositive ? null : { capacity: { min: change + 10 } }
        }),
        true,
        EventType.PERSONAL,
        1
      );
    }
  }
};
```

### 4.2 事件变化生成器

创建一个可以基于现有事件生成变体的工具，增加事件多样性。

```javascript
// src/core/services/eventVariationGenerator.js
export class EventVariationGenerator {
  /**
   * 根据基础事件生成变体事件
   * @param {Object} baseEvent - 基础事件对象
   * @param {Object} variations - 变体参数
   * @returns {Object} 新的事件变体
   */
  static generateVariation(baseEvent, variations = {}) {
    // 创建基础事件的深拷贝
    const newEvent = JSON.parse(JSON.stringify(baseEvent));
    
    // 应用变化
    if (variations.id) newEvent.id = variations.id;
    if (variations.title) newEvent.title = variations.title;
    if (variations.description) newEvent.description = variations.description;
    
    // 修改选项
    if (variations.options) {
      variations.options.forEach((optVar, index) => {
        if (index < newEvent.options.length && optVar) {
          if (optVar.text) newEvent.options[index].text = optVar.text;
          if (optVar.result) newEvent.options[index].result = optVar.result;
          
          // 修改效果
          if (optVar.effects) {
            Object.entries(optVar.effects).forEach(([key, value]) => {
              newEvent.options[index].effects[key] = value;
            });
          }
        }
      });
    }
    
    // 修改条件
    if (variations.conditions) {
      Object.entries(variations.conditions).forEach(([key, value]) => {
        newEvent.conditions[key] = value;
      });
    }
    
    return newEvent;
  }
  
  /**
   * 批量生成事件变体
   * @param {Object} baseEvent - 基础事件对象
   * @param {Array<Object>} variationsList - 变体参数列表
   * @returns {Array<Object>} 事件变体列表
   */
  static generateVariations(baseEvent, variationsList) {
    return variationsList.map(vars => this.generateVariation(baseEvent, vars));
  }
}
```

### 4.3 动态事件描述系统

实现一个根据玩家状态动态生成事件描述的系统，增加事件的个性化体验。

```javascript
// src/core/services/dynamicEventDescriptionService.js
export class DynamicEventDescriptionService {
  /**
   * 根据游戏状态生成动态事件描述
   * @param {Object} baseDescription - 基础描述模板
   * @param {Object} gameState - 当前游戏状态
   * @returns {string} 生成的描述
   */
  static generateDescription(baseDescription, gameState) {
    // 替换玩家名称
    let description = baseDescription.replace('{playerName}', gameState.player.name);
    
    // 替换当前地点
    if (gameState.currentLocation && gameState.currentLocation.name) {
      description = description.replace('{locationName}', gameState.currentLocation.name);
    }
    
    // 替换当前周数
    description = description.replace('{currentWeek}', gameState.currentWeek);
    
    // 替换玩家金钱
    description = description.replace('{playerMoney}', gameState.player.money);
    
    // 更多动态替换...
    
    return description;
  }
  
  /**
   * 生成与玩家状态相关的动态事件选项
   * @param {Object} event - 事件对象
   * @param {Object} gameState - 当前游戏状态
   * @returns {Array} 动态生成的事件选项
   */
  static generateDynamicOptions(event, gameState) {
    const dynamicOptions = [];
    
    // 根据玩家资金状况生成不同选项
    if (gameState.player.money > 10000) {
      dynamicOptions.push(
        createEventOption(
          '大额投资',
          '你用充足的资金进行了大额投资，获得了可观的回报。',
          createEventEffects({ money: 2000 })
        )
      );
    } else if (gameState.player.money < 1000) {
      dynamicOptions.push(
        createEventOption(
          '谨慎选择',
          '由于资金有限，你选择了风险较小的方案。',
          createEventEffects({ money: 500 })
        )
      );
    }
    
    // 根据背包物品生成选项
    const hasElectronics = gameState.player.inventory.some(
      item => gameState.products.find(p => p.id === item.productId)?.category === 'ELECTRONICS'
    );
    
    if (hasElectronics) {
      dynamicOptions.push(
        createEventOption(
          '交换电子产品',
          '你用自己的电子产品做了一笔有利的交易。',
          createEventEffects({
            // 移除一个电子产品
            items: [{ productId: gameState.player.inventory.find(
              item => gameState.products.find(p => p.id === item.productId)?.category === 'ELECTRONICS'
            ).productId, quantity: -1 }],
            // 获得资金
            money: 1500
          })
        )
      );
    }
    
    return dynamicOptions;
  }
}
```

### 4.4 事件策略系统

创建一个根据游戏阶段和玩家表现调整事件生成的策略系统。

```javascript
// src/core/services/eventStrategyService.js
export class EventStrategyService {
  /**
   * 根据游戏阶段选择合适的事件
   * @param {Array} events - 所有可用事件
   * @param {Object} gameState - 当前游戏状态
   * @returns {Array} 适合当前游戏阶段的事件
   */
  static selectEventsForPhase(events, gameState) {
    const { currentWeek, maxWeeks } = gameState;
    const gameProgress = currentWeek / maxWeeks;
    
    // 定义游戏阶段
    let currentPhase;
    if (gameProgress < 0.3) currentPhase = 'early';
    else if (gameProgress < 0.7) currentPhase = 'mid';
    else currentPhase = 'late';
    
    // 根据阶段筛选事件并调整权重
    return events.map(event => {
      // 克隆事件以避免修改原始数据
      const adjustedEvent = JSON.parse(JSON.stringify(event));
      
      // 根据游戏阶段调整事件权重
      switch (currentPhase) {
        case 'early':
          // 早期阶段增加教程和正面事件权重
          if (event.type === EventType.TUTORIAL) adjustedEvent.weight *= 2;
          if (event.effectType === 'positive') adjustedEvent.weight *= 1.3;
          break;
          
        case 'mid':
          // 中期阶段增加市场和商业事件权重
          if (event.type === EventType.MARKET) adjustedEvent.weight *= 1.5;
          break;
          
        case 'late':
          // 后期阶段增加房产和高风险高回报事件权重
          if (event.id.includes('property') || event.id.includes('invest')) {
            adjustedEvent.weight *= 2;
          }
          break;
      }
      
      return adjustedEvent;
    });
  }
  
  /**
   * 根据玩家表现动态调整事件难度
   * @param {Object} event - 事件对象
   * @param {Object} gameState - 当前游戏状态
   * @returns {Object} 调整后的事件
   */
  static adjustEventDifficulty(event, gameState) {
    // 克隆事件以避免修改原始数据
    const adjustedEvent = JSON.parse(JSON.stringify(event));
    
    // 计算玩家表现指标
    const performanceScore = this.calculatePlayerPerformance(gameState);
    
    // 根据表现调整事件难度
    if (performanceScore > 0.8) { // 玩家表现优秀
      // 增加事件难度和奖励
      adjustedEvent.options.forEach(option => {
        // 如果是金钱奖励，增加数额但增加风险
        if (option.effects.money > 0) {
          option.effects.money *= 1.3; // 增加30%奖励
          
          // 添加额外风险
          if (Math.random() < 0.3) { // 30%的概率添加负面效果
            option.effects.market = option.effects.market || {};
            option.effects.market.globalPriceModifier = 0.9; // 市场价格小幅下降
            option.effects.market.duration = 1;
          }
        }
      });
    } else if (performanceScore < 0.3) { // 玩家表现不佳
      // 降低事件难度，增加辅助
      adjustedEvent.options.forEach(option => {
        // 减少金钱损失
        if (option.effects.money < 0) {
          option.effects.money *= 0.7; // 减少30%的损失
        }
        
        // 增加小额奖励机会
        if (option.effects.money === 0 && Math.random() < 0.4) {
          option.effects.money = Math.floor(gameState.player.money * 0.05); // 增加5%的资金作为小奖励
        }
      });
    }
    
    return adjustedEvent;
  }
  
  /**
   * 计算玩家表现指标
   * @param {Object} gameState - 当前游戏状态
   * @returns {number} 表现分数 (0-1)
   */
  static calculatePlayerPerformance(gameState) {
    const { player, currentWeek } = gameState;
    
    // 计算预期财富增长
    const expectedMoney = 5000 + (currentWeek * 1000); // 简单模型：初始5000，每周预期增加1000
    const moneyRatio = player.money / expectedMoney;
    
    // 计算债务比率
    const debtRatio = player.debt > 0 ? 
      player.money / player.debt : 
      1; // 无债务时为最高分1
    
    // 综合评分
    let score = (moneyRatio * 0.7) + (debtRatio * 0.3);
    
    // 限制在0-1范围内
    return Math.max(0, Math.min(1, score));
  }
}
```

### 4.5 事件组合系统

设计一个事件组合系统，用于创建更加复杂的事件序列和分支。

```javascript
// src/core/services/eventCompositionService.js
export class EventCompositionService {
  /**
   * 创建复合事件序列
   * @param {string} baseId - 基础事件ID
   * @param {Array<Object>} eventSteps - 事件步骤
   * @returns {Array<Object>} 事件序列
   */
  static createEventSequence(baseId, eventSteps) {
    return eventSteps.map((step, index) => {
      const eventId = `${baseId}_step${index + 1}`;
      const nextEventId = index < eventSteps.length - 1 ? `${baseId}_step${index + 2}` : null;
      
      return createEvent(
        eventId,
        step.title,
        step.description,
        step.options.map(opt => {
          // 如果不是最后一步，每个选项都设置下一个事件
          if (nextEventId) {
            return createEventOption(
              opt.text,
              opt.result,
              createEventEffects({
                ...opt.effects,
                nextEvent: nextEventId
              })
            );
          }
          return createEventOption(opt.text, opt.result, createEventEffects(opt.effects));
        }),
        step.conditions || createEventConditions({}),
        false, // 复合事件序列中的事件通常不可重复
        step.type || EventType.STORY,
        step.weight || 1,
        step.imageUrl
      );
    });
  }
  
  /**
   * 创建分支事件
   * @param {Object} baseEvent - 基础事件
   * @param {Object} branches - 分支定义
   * @returns {Array<Object>} 包含所有分支的事件列表
   */
  static createBranchedEvent(baseEvent, branches) {
    // 创建起始事件
    const startEvent = JSON.parse(JSON.stringify(baseEvent));
    
    // 创建每个分支的事件
    const branchEvents = [];
    
    // 修改起始事件的选项，添加分支跳转
    startEvent.options = startEvent.options.map((option, index) => {
      if (branches[index]) {
        // 设置该选项触发相应的分支事件
        option.effects.nextEvent = `${startEvent.id}_branch${index + 1}`;
        
        // 创建分支事件
        const branchEvent = createEvent(
          `${startEvent.id}_branch${index + 1}`,
          branches[index].title,
          branches[index].description,
          branches[index].options,
          createEventConditions({
            // 分支事件通常只通过主事件触发，不会自然生成
            probability: 0
          }),
          false,
          branches[index].type || startEvent.type,
          0, // 权重为0，不会自然生成
          branches[index].imageUrl
        );
        
        branchEvents.push(branchEvent);
      }
      return option;
    });
    
    return [startEvent, ...branchEvents];
  }
}
```

### 4.6 修改事件生成系统

修改现有的事件生成系统，整合新增的模板和策略。

```javascript
// 添加到 src/core/models/event.js 底部

// 使用模板系统批量生成事件
function generateTemplatedEvents() {
  const events = [];
  
  // 生成市场价格变化事件
  const categories = ['电子产品', '奢侈品', '生活用品', '食品', '原材料'];
  categories.forEach(category => {
    // 生成价格上涨事件
    events.push(EventTemplates.MARKET_PRICE_CHANGE.generateEvent(
      category, 1.3, true // 价格上涨30%
    ));
    
    // 生成价格下跌事件
    events.push(EventTemplates.MARKET_PRICE_CHANGE.generateEvent(
      category, 0.7, false // 价格下跌30%
    ));
  });
  
  // 生成财富变化事件
  const fortuneAmounts = [500, 1000, 2000, 5000];
  fortuneAmounts.forEach(amount => {
    // 生成正面财富事件
    events.push(EventTemplates.FORTUNE_CHANGE.generateEvent(
      amount, true // 获得财富
    ));
    
    // 生成负面财富事件
    events.push(EventTemplates.FORTUNE_CHANGE.generateEvent(
      amount, false // 损失财富
    ));
  });
  
  // 生成背包容量变化事件
  const capacityChanges = [5, 10, 20];
  capacityChanges.forEach(change => {
    // 生成背包容量增加事件
    events.push(EventTemplates.CAPACITY_CHANGE.generateEvent(
      change, true // 容量增加
    ));
    
    // 生成背包容量减少事件
    events.push(EventTemplates.CAPACITY_CHANGE.generateEvent(
      change, false // 容量减少
    ));
  });
  
  return events;
}

// 修改 getAllEvents 函数，整合模板生成的事件
export function getAllEvents() {
  // 获取静态定义的事件
  const staticEvents = events;
  
  // 获取从模板生成的事件
  const templatedEvents = generateTemplatedEvents();
  
  // 合并所有事件
  return [...staticEvents, ...templatedEvents];
}
```

### 4.7 地区特定事件系统

实现针对不同地区触发特定事件的机制，特别是类似黑市这样的特殊地点。

#### 4.7.1 地区特性系统

```javascript
// src/core/models/location.js
export const LocationTraits = {
  BLACK_MARKET: {
    name: '黑市',
    eventMultiplier: 1.5, // 事件触发概率提高50%
    eventTypes: ['illegal', 'risky', 'rare'], // 事件类型标签
    specialProducts: ['contraband', 'exotic'], // 特殊商品类型
    riskLevel: 'high', // 风险等级
    description: '隐蔽的交易场所，可能遇到危险但回报丰厚的机会'
  },
  PREMIUM_MALL: {
    name: '高端商城',
    eventMultiplier: 1.2,
    eventTypes: ['luxury', 'celebrity', 'business'],
    specialProducts: ['luxury', 'fashion'],
    riskLevel: 'low',
    description: '高端商品交易中心，可能遇到名人和商业机会'
  },
  ELECTRONICS_HUB: {
    name: '电子科技城',
    eventMultiplier: 1.3,
    eventTypes: ['tech', 'innovation', 'discount'],
    specialProducts: ['electronics', 'gadgets'],
    riskLevel: 'medium',
    description: '电子产品交易中心，常有新品发布和技术交流活动'
  }
  // 更多地区特性...
};

// 为每个地点添加特性
export function enhanceLocation(location) {
  const trait = LocationTraits[location.id.toUpperCase()];
  if (trait) {
    return {
      ...location,
      trait,
      eventProbability: (location.eventProbability || 0.3) * trait.eventMultiplier
    };
  }
  return location;
}
```

#### 4.7.2 地区特定事件模板

```javascript
// src/core/models/locationEventTemplates.js
export const LocationEventTemplates = {
  // 黑市特定事件模板
  BLACK_MARKET: {
    // 黑市交易机会
    ILLEGAL_DEAL: {
      generateEvent: (riskLevel, rewardMultiplier) => {
        const id = `black_market_deal_${Date.now()}`;
        const title = '可疑交易机会';
        const description = '一个神秘人向你低声提议一笔利润丰厚但风险较高的交易。';
        
        return createEvent(
          id,
          title,
          description,
          [
            createEventOption(
              '接受交易',
              riskLevel === 'high' ? 
                '你冒险接受了交易，幸运的是一切顺利，获得了丰厚回报！' : 
                '你接受了交易，获得了不错的收益。',
              createEventEffects({ 
                money: 2000 * rewardMultiplier,
                // 高风险有概率触发后续事件
                nextEvent: riskLevel === 'high' && Math.random() > 0.7 ? 'black_market_police' : null
              })
            ),
            createEventOption(
              '谨慎拒绝',
              '你婉拒了这个看起来风险较高的交易。',
              createEventEffects({})
            )
          ],
          createEventConditions({ 
            locations: ['black_market'],
            probability: 0.3
          }),
          true,
          EventType.LOCATION,
          1.5
        );
      }
    },
    
    // 黑市特殊商品
    RARE_ITEM: {
      generateEvent: () => {
        const id = `black_market_rare_item_${Date.now()}`;
        const title = '稀有商品';
        const description = '你在黑市深处发现了一个摊位，上面摆放着一些罕见的商品。';
        
        const rareItems = [
          { id: 'rare_antique', name: '古董花瓶', price: 8000, resaleValue: 15000 },
          { id: 'tech_prototype', name: '技术原型机', price: 12000, resaleValue: 20000 },
          { id: 'exotic_material', name: '稀有材料', price: 5000, resaleValue: 9000 }
        ];
        
        // 随机选择一个稀有物品
        const item = rareItems[Math.floor(Math.random() * rareItems.length)];
        
        return createEvent(
          id,
          title,
          description,
          [
            createEventOption(
              `购买${item.name}`,
              `你花了一大笔钱购买了${item.name}，这在普通市场上很难找到。`,
              createEventEffects({ 
                money: -item.price,
                items: [{ 
                  productId: item.id, 
                  quantity: 1,
                  price: item.resaleValue 
                }]
              }),
              // 条件：玩家有足够的钱
              (gameState) => gameState.player.money >= item.price
            ),
            createEventOption(
              '离开',
              '你决定不冒险购买这些来源不明的商品。',
              createEventEffects({})
            )
          ],
          createEventConditions({ 
            locations: ['black_market'],
            probability: 0.25,
            // 需要玩家至少有一定资金才会触发
            playerMoney: { min: 5000 }
          }),
          true,
          EventType.LOCATION,
          1.2
        );
      }
    }
  },
  
  // 高端商城特定事件
  PREMIUM_MALL: {
    // 名人活动
    CELEBRITY_EVENT: {
      generateEvent: () => {
        // 实现高端商城特定的名人活动事件
      }
    },
    
    // 奢侈品促销
    LUXURY_SALE: {
      generateEvent: () => {
        // 实现奢侈品促销事件
      }
    }
  },
  
  // 电子科技城特定事件
  ELECTRONICS_HUB: {
    // 新品发布会
    NEW_PRODUCT_LAUNCH: {
      generateEvent: () => {
        // 实现电子产品发布会事件
      }
    },
    
    // 技术交流
    TECH_EXCHANGE: {
      generateEvent: () => {
        // 实现技术交流事件
      }
    }
  }
};
```

#### 4.7.3 地区事件生成器

```javascript
// src/core/services/locationEventGenerator.js
export class LocationEventGenerator {
  /**
   * 根据当前地点生成特定事件
   * @param {Object} location - 地点对象
   * @param {Object} gameState - 游戏状态
   * @returns {Object|null} 生成的事件
   */
  static generateLocationEvent(location, gameState) {
    if (!location) return null;
    
    // 获取地点特性
    const locationId = location.id.toUpperCase();
    const templates = LocationEventTemplates[locationId];
    
    // 如果没有该地点的特定模板，返回null
    if (!templates) return null;
    
    // 计算玩家状态
    const playerWealth = this.calculatePlayerWealthLevel(gameState);
    const playerRisk = this.calculatePlayerRiskTolerance(gameState);
    
    // 根据玩家状态选择适合的事件模板
    const templateKeys = Object.keys(templates);
    let eligibleTemplates = templateKeys;
    
    // 根据玩家风险承受能力筛选事件
    if (playerRisk === 'low') {
      // 低风险偏好玩家过滤掉高风险事件
      eligibleTemplates = templateKeys.filter(key => 
        !key.includes('ILLEGAL') && !key.includes('RISKY')
      );
    } else if (playerRisk === 'high') {
      // 高风险偏好玩家增加高风险事件权重
      const riskEvents = templateKeys.filter(key => 
        key.includes('ILLEGAL') || key.includes('RISKY')
      );
      
      // 添加额外的高风险事件复制品，增加抽取概率
      eligibleTemplates = [...templateKeys, ...riskEvents];
    }
    
    // 如果没有合适的模板，返回null
    if (eligibleTemplates.length === 0) return null;
    
    // 随机选择一个模板
    const selectedKey = eligibleTemplates[Math.floor(Math.random() * eligibleTemplates.length)];
    const template = templates[selectedKey];
    
    // 根据玩家财富状况调整奖励倍率
    const rewardMultiplier = playerWealth === 'high' ? 1.5 : (playerWealth === 'medium' ? 1.2 : 1);
    
    // 根据玩家风险承受能力调整风险等级
    const riskLevel = playerRisk === 'high' ? 'high' : (playerRisk === 'medium' ? 'medium' : 'low');
    
    // 生成事件
    return template.generateEvent(riskLevel, rewardMultiplier);
  }
  
  /**
   * 计算玩家财富等级
   * @param {Object} gameState - 游戏状态
   * @returns {string} 财富等级 ('low', 'medium', 'high')
   */
  static calculatePlayerWealthLevel(gameState) {
    const money = gameState.player.money;
    
    if (money > 50000) return 'high';
    if (money > 10000) return 'medium';
    return 'low';
  }
  
  /**
   * 计算玩家风险承受能力
   * @param {Object} gameState - 游戏状态
   * @returns {string} 风险承受能力 ('low', 'medium', 'high')
   */
  static calculatePlayerRiskTolerance(gameState) {
    // 根据玩家历史行为评估风险承受能力
    const riskyChoices = gameState.player.statistics?.riskyChoices || 0;
    const totalChoices = gameState.player.statistics?.totalChoices || 1;
    
    const riskRatio = riskyChoices / totalChoices;
    
    if (riskRatio > 0.7) return 'high';
    if (riskRatio > 0.4) return 'medium';
    return 'low';
  }
}
```

#### 4.7.4 整合到事件系统

```javascript
// 修改 src/core/services/eventSystem.js

// 在 checkForEvents 方法中添加地区特定事件生成逻辑
checkForEvents(gameState, eventType = null) {
  console.log('事件系统 - 检查是否触发事件, 当前周数:', gameState.currentWeek);
  console.log('事件系统 - 当前地点:', gameState.currentLocation ? gameState.currentLocation.id : '未知');
  
  // 首先尝试生成地区特定事件
  if (gameState.currentLocation) {
    const locationEvent = LocationEventGenerator.generateLocationEvent(
      gameState.currentLocation, 
      gameState
    );
    
    if (locationEvent) {
      console.log('事件系统 - 生成地区特定事件:', locationEvent.id, locationEvent.title);
      this.recordEvent(locationEvent.id, gameState.currentWeek);
      
      eventEmitter.emit(GameEventType.EVENT_TRIGGERED, {
        event: locationEvent,
        week: gameState.currentWeek,
        isLocationSpecific: true
      });
      
      return locationEvent;
    }
  }
  
  // 如果没有地区特定事件，继续原有逻辑生成一般事件
  // ... 原有代码 ...
}
```

## 5. 事件内容优化计划

### 5.1 事件类别重构

将现有事件重新分类为以下几个大类，每个大类下再细分子类：

1. **市场事件**
   - 价格波动事件
   - 供需变化事件
   - 特殊商品事件

2. **个人事件**
   - 财富变化事件
   - 背包相关事件
   - 技能提升事件

3. **故事事件**
   - 主线剧情事件
   - 连锁事件
   - 分支故事事件

4. **地点事件**
   - 特定地点专属事件
   - 地点解锁事件
   - 旅行事件

5. **房产事件**
   - 房产市场变化事件
   - 房产相关机会事件
   - 房产维护事件

### 5.2 新增事件链和分支故事

1. **投资者故事线**
   - 开始事件：遇到投资者
   - 分支1：合作投资
   - 分支2：独立运营
   - 结局多样化

2. **黑市交易故事线**
   - 开始事件：黑市邀请
   - 中间事件：走私计划
   - 选择分支：隐蔽路线/正面突破
   - 多结局：成功交易/危机冲突/任务失败
   - 影响：黑市声望变化、特殊商品解锁、风险与高额回报

3. **房产经纪人故事线**
   - 开始事件：结识房产经纪人
   - 选择合作方式
   - 影响房产购买决策

### 5.3 动态事件内容生成

1. **场景动态描述**
   - 根据当前地点调整事件描述
   - 根据游戏周数调整事件背景
   - 根据玩家财富状况调整事件语调

2. **选项动态生成**
   - 根据玩家背包内容生成特殊选项
   - 根据玩家资金状况调整风险选项
   - 根据玩家过往选择调整事件结果

## 6. 实施计划

### 6.1 阶段划分

**阶段一：基础结构实现（2周）**
- 实现事件模板系统
- 实现事件变化生成器
- 编写单元测试

**阶段二：内容转换与优化（3周）**
- 将现有事件重构为模板
- 实现动态事件描述系统
- 设计新的事件分支系统

**阶段三：策略系统与平衡（2周）**
- 实现事件策略系统
- 事件难度动态调整
- 游戏平衡测试与调整

**阶段四：故事内容扩展（3周）**
- 设计并实现新的故事线
- 创建复杂的分支事件序列
- 增加特殊成就和隐藏内容

### 6.2 风险评估与对策

| 风险 | 影响 | 可能性 | 对策 |
|------|------|--------|------|
| 模板系统导致事件内容过于类似 | 高 | 中 | 增加变量参数，确保模板多样性 |
| 动态事件生成导致游戏不稳定 | 高 | 低 | 完善单元测试，增加异常处理 |
| 新系统与现有代码整合困难 | 中 | 中 | 采用渐进式重构，保持兼容性 |
| 事件平衡性问题 | 中 | 高 | 开发专门的平衡测试工具，定期调整 |
| 开发周期延长 | 低 | 中 | 模块化开发，优先实现核心功能 |

## 7. 总结

本次事件系统优化将从根本上改善游戏的事件体验，提高游戏的可玩性和趣味性。通过事件模板系统、变化生成器、动态描述和策略系统，我们可以显著减少事件内容的重复性，提供更加丰富多彩的游戏体验。同时，新增的事件组合系统将使我们能够创建更加复杂的事件序列和分支故事，进一步增强游戏的叙事深度。

优化后的事件系统将具有更好的可维护性和扩展性，使得未来添加新的事件内容变得更加简单高效。我们相信这些改进将显著提升玩家的游戏体验，增加游戏的重玩价值。 

## 8. 进一步完善方向

除了以上设计和实现的优化方案，事件系统还可以在以下几个方面进一步完善，以提供更加深度和个性化的游戏体验：

### 8.1 事件反馈循环系统

设计一个长期事件反馈循环系统，使玩家的早期决策能够在游戏后期产生连锁反应，增强游戏的深度和连续性。

```javascript
// src/core/services/eventFeedbackSystem.js
export class EventFeedbackSystem {
  /**
   * 创建延迟反馈事件
   * @param {Object} gameState - 游戏状态
   * @param {string} playerChoice - 玩家选择的事件ID或选项ID
   * @param {number} delayWeeks - 延迟触发的周数
   * @returns {Object} 延迟事件配置
   */
  static createDelayedConsequence(gameState, playerChoice, delayWeeks) {
    // 记录玩家选择并在指定周数后触发后续事件
    return {
      triggerWeek: gameState.currentWeek + delayWeeks,
      baseEvent: `consequence_of_${playerChoice}`,
      playerState: {...gameState.player} // 记录当时的玩家状态
    };
  }
  
  /**
   * 根据玩家历史决策生成适当的反馈事件
   * @param {Object} gameState - 当前游戏状态
   * @param {Array} playerDecisionHistory - 玩家历史决策记录
   * @returns {Object|null} 生成的反馈事件，如果无则返回null
   */
  static generateFeedbackEvent(gameState, playerDecisionHistory) {
    const significantDecisions = playerDecisionHistory.filter(d => 
      d.significance > 0.7 && 
      gameState.currentWeek - d.week >= d.feedbackDelay
    );
    
    if (significantDecisions.length === 0) return null;
    
    // 按重要性排序
    significantDecisions.sort((a, b) => b.significance - a.significance);
    
    // 获取最重要的决策
    const topDecision = significantDecisions[0];
    
    // 根据决策类型生成不同的反馈事件
    switch (topDecision.category) {
      case 'MARKET_MANIPULATION':
        return this.createMarketFeedbackEvent(topDecision, gameState);
      case 'SOCIAL_RELATIONSHIP':
        return this.createSocialFeedbackEvent(topDecision, gameState);
      case 'RISKY_INVESTMENT':
        return this.createInvestmentFeedbackEvent(topDecision, gameState);
      default:
        return this.createGenericFeedbackEvent(topDecision, gameState);
    }
  }
}
```

### 8.2 事件频率动态平衡

实现事件频率的动态平衡系统，防止特定类型的事件过于频繁或稀少，提供更均衡的游戏体验。

```javascript
// src/core/services/eventBalancer.js
export class EventBalancer {
  /**
   * 计算事件触发概率
   * @param {string} eventType - 事件类型
   * @param {Object} gameState - 游戏状态
   * @returns {number} 计算后的触发概率
   */
  static calculateEventProbability(eventType, gameState) {
    // 基础概率
    let baseProbability = EVENT_BASE_PROBABILITIES[eventType] || 0.2;
    
    // 根据该类型事件的历史触发频率进行调整
    const recentEvents = gameState.eventHistory.filter(e => 
      e.type === eventType && 
      gameState.currentWeek - e.week <= 10
    );
    
    // 该类型事件最近出现过多，降低概率
    if (recentEvents.length > 3) {
      baseProbability *= 0.5;
    } 
    // 该类型事件最近较少，提高概率
    else if (recentEvents.length < 1) {
      baseProbability *= 1.5;
    }
    
    // 根据游戏阶段进行调整
    const gameProgress = gameState.currentWeek / gameState.maxWeeks;
    if (EVENT_STAGE_WEIGHTS[eventType]) {
      const stageWeight = EVENT_STAGE_WEIGHTS[eventType].find(s => 
        gameProgress >= s.minProgress && gameProgress <= s.maxProgress
      );
      
      if (stageWeight) {
        baseProbability *= stageWeight.multiplier;
      }
    }
    
    // 确保概率在合理范围内
    return Math.min(0.95, Math.max(0.05, baseProbability));
  }
  
  /**
   * 平衡事件选择
   * @param {Array} events - 可选事件列表
   * @param {Object} gameState - 游戏状态
   * @returns {Array} 平衡后的事件列表（带权重）
   */
  static balanceEventSelection(events, gameState) {
    const eventCounts = this.countRecentEvents(gameState.eventHistory);
    const eventPool = {};
    
    // 将事件按类型分组
    events.forEach(event => {
      if (!eventPool[event.type]) {
        eventPool[event.type] = [];
      }
      eventPool[event.type].push(event);
    });
    
    // 调整各类型事件的总体权重
    const result = [];
    Object.entries(eventPool).forEach(([type, typeEvents]) => {
      const count = eventCounts[type] || 0;
      
      // 类型权重调整
      const typeWeight = count > 5 ? 0.7 : (count < 2 ? 1.5 : 1.0);
      
      // 添加调整后的事件
      typeEvents.forEach(event => {
        result.push({
          ...event,
          adjustedWeight: event.weight * typeWeight
        });
      });
    });
    
    return result;
  }
}
```

### 8.3 玩家行为分析与个性化事件

设计玩家行为分析系统，基于玩家的游戏风格和决策模式提供个性化的事件内容。

```javascript
// src/core/services/playerBehaviorAnalyzer.js
export class PlayerBehaviorAnalyzer {
  /**
   * 分析玩家游戏风格
   * @param {Object} gameState - 游戏状态
   * @returns {Object} 玩家风格分析结果
   */
  static analyzePlayStyle(gameState) {
    const stats = gameState.player.statistics || {};
    const choices = stats.eventChoices || [];
    
    return {
      // 风险偏好 (0-1)
      riskTolerance: this.calculateRiskTolerance(choices),
      
      // 交易风格 (持有/频繁交易)
      tradingStyle: this.determineTradingStyle(gameState),
      
      // 最感兴趣的商品类别
      favoriteCategory: this.determineFavoriteCategory(gameState),
      
      // 地点偏好
      locationPreference: this.determineLocationPreference(gameState),
      
      // 决策偏好
      decisionPreference: {
        economic: this.calculateDecisionWeight(choices, 'ECONOMIC'),
        social: this.calculateDecisionWeight(choices, 'SOCIAL'),
        opportunistic: this.calculateDecisionWeight(choices, 'OPPORTUNISTIC'),
        strategic: this.calculateDecisionWeight(choices, 'STRATEGIC')
      }
    };
  }
  
  /**
   * 推荐个性化事件
   * @param {Object} playStyle - 玩家风格分析结果
   * @param {Array} allEvents - 所有可用事件
   * @returns {Array} 个性化排序和权重调整后的事件
   */
  static recommendPersonalizedEvents(playStyle, allEvents) {
    return allEvents.filter(event => {
      // 根据玩家风格筛选适合的事件
      if (event.type === 'RISK' && Math.abs(event.riskLevel - playStyle.riskTolerance) > 0.3) {
        return false;
      }
      
      // 推荐与玩家交易风格相符的事件
      if (event.tradingStyleTarget && event.tradingStyleTarget !== playStyle.tradingStyle) {
        return false;
      }
      
      return true;
    }).map(event => ({
      ...event,
      weight: this.calculatePersonalizedWeight(event, playStyle)
    }));
  }
  
  /**
   * 计算个性化事件权重
   * @param {Object} event - 事件对象
   * @param {Object} playStyle - 玩家风格分析结果
   * @returns {number} 调整后的权重
   */
  static calculatePersonalizedWeight(event, playStyle) {
    let weight = event.weight || 1;
    
    // 根据风险偏好调整
    if (event.tags && event.tags.includes('RISKY')) {
      const riskDelta = Math.abs(event.riskLevel - playStyle.riskTolerance);
      weight *= (1 - riskDelta);
    }
    
    // 根据商品类别偏好调整
    if (event.relatedCategory && event.relatedCategory === playStyle.favoriteCategory) {
      weight *= 1.3;
    }
    
    // 根据地点偏好调整
    if (event.location && playStyle.locationPreference.includes(event.location)) {
      weight *= 1.2;
    }
    
    // 根据决策偏好调整
    if (event.decisionType && playStyle.decisionPreference[event.decisionType.toLowerCase()]) {
      const preferenceLevel = playStyle.decisionPreference[event.decisionType.toLowerCase()];
      weight *= (1 + preferenceLevel * 0.3);
    }
    
    return weight;
  }
}
```

### 8.4 复杂条件触发系统

扩展现有的事件触发条件系统，支持更复杂的逻辑组合条件，如AND、OR、NOT等复合条件。

```javascript
// src/core/models/advancedEventConditions.js
export class AdvancedEventConditions extends EventConditions {
  /**
   * 创建高级事件条件实例
   * @param {Object} options - 条件初始化配置
   */
  constructor(options) {
    super(options);
    
    // 添加复合条件支持
    this.andConditions = options.andConditions || []; // 必须全部满足
    this.orConditions = options.orConditions || [];  // 满足一个即可
    this.notConditions = options.notConditions || []; // 必须全部不满足
  }
  
  /**
   * 检查复杂条件
   * @param {Object} gameState - 游戏状态
   * @returns {boolean} 是否满足条件
   */
  checkComplexConditions(gameState) {
    // 检查基本条件
    if (!super.check(gameState)) {
      return false;
    }
    
    // 检查AND条件组 - 全部必须满足
    const andResult = this.andConditions.length === 0 || 
      this.andConditions.every(condition => condition.check(gameState));
    
    // 检查OR条件组 - 满足一个即可
    const orResult = this.orConditions.length === 0 || 
      this.orConditions.some(condition => condition.check(gameState));
    
    // 检查NOT条件组 - 全部必须不满足
    const notResult = this.notConditions.length === 0 || 
      this.notConditions.every(condition => !condition.check(gameState));
    
    return andResult && orResult && notResult;
  }
  
  /**
   * 创建条件组合器
   * @param {Array} conditions - 条件列表
   * @param {string} type - 组合类型 ('AND', 'OR', 'NOT')
   * @returns {AdvancedEventConditions} 组合后的条件
   */
  static combineConditions(conditions, type) {
    const options = {};
    
    switch (type) {
      case 'AND':
        options.andConditions = conditions;
        break;
      case 'OR':
        options.orConditions = conditions;
        break;
      case 'NOT':
        options.notConditions = conditions;
        break;
    }
    
    return new AdvancedEventConditions(options);
  }
}
```

### 8.5 事件可测试性与调试功能

实现事件系统的测试和调试工具，便于开发者快速验证和平衡事件内容。

```javascript
// src/dev/eventTester.js
export class EventTester {
  /**
   * 模拟事件序列
   * @param {Object} baseEvent - 起始事件
   * @param {Array} playerChoices - 玩家选择序列
   * @param {Object} initialGameState - 初始游戏状态
   * @returns {Object} 模拟结果
   */
  static simulateEventSequence(baseEvent, playerChoices, initialGameState) {
    let gameState = {...initialGameState};
    let events = [];
    let currentEvent = baseEvent;
    
    for (let i = 0; i < playerChoices.length; i++) {
      const choice = playerChoices[i];
      events.push({
        event: currentEvent,
        choice: choice
      });
      
      // 模拟选择的效果
      gameState = this.applyEventChoice(currentEvent, choice, gameState);
      
      // 获取下一个事件
      const nextEventId = currentEvent.options[choice].effects.nextEvent;
      if (!nextEventId) break;
      
      currentEvent = getEventById(nextEventId);
      if (!currentEvent) break;
    }
    
    return {
      events,
      finalState: gameState,
      summary: this.generateEventSummary(events, gameState)
    };
  }
  
  /**
   * 生成事件调试视图
   * @param {Object} event - 事件对象
   * @param {Object} gameState - 游戏状态
   * @returns {Object} 调试视图数据
   */
  static generateDebugView(event, gameState) {
    return {
      event: {
        id: event.id,
        title: event.title,
        conditions: this.explainConditions(event.conditions, gameState),
        options: event.options.map(opt => ({
          text: opt.text,
          available: opt.condition ? opt.condition(gameState) : true,
          effects: this.explainEffects(opt.effects, gameState)
        }))
      },
      nextEvents: this.getPotentialNextEvents(event),
      triggerProbability: this.calculateTriggerProbability(event, gameState)
    };
  }
  
  /**
   * 批量测试事件平衡性
   * @param {Array} events - 事件列表
   * @param {Object} testConfig - 测试配置
   * @returns {Object} 测试结果分析
   */
  static batchTestEventBalance(events, testConfig) {
    const results = {
      eventFrequency: {},
      pathCompletion: {},
      playerStateImpact: {},
      anomalies: []
    };
    
    // 执行多次模拟
    for (let i = 0; i < testConfig.iterations; i++) {
      const simulationResult = this.simulateFullGame(events, testConfig);
      
      // 统计事件触发频率
      simulationResult.triggeredEvents.forEach(e => {
        results.eventFrequency[e.id] = (results.eventFrequency[e.id] || 0) + 1;
      });
      
      // 分析其他数据
      this.analyzeSimulationResult(simulationResult, results);
    }
    
    // 计算最终统计
    this.calculateFinalStatistics(results, testConfig.iterations);
    
    return results;
  }
}
```

### 8.6 动态多层事件叙事系统

设计一个动态叙事系统，根据玩家的游戏进度和风格提供个性化的故事内容。

```javascript
// src/core/services/dynamicNarrationSystem.js
export class DynamicNarrationSystem {
  /**
   * 根据游戏进度生成不同阶段的叙事事件
   * @param {string} gameStage - 游戏阶段
   * @param {Object} gameState - 游戏状态
   * @returns {Array} 生成的叙事事件列表
   */
  static generateNarrationForStage(gameStage, gameState) {
    const baseEvents = NARRATION_TEMPLATES[gameStage] || [];
    const playerArc = this.determinePlayerArc(gameState);
    
    return baseEvents.map(event => {
      // 根据玩家当前"故事弧"选择合适的叙事变体
      const narrativeVariants = event.narrativeVariants || {};
      const selectedVariant = narrativeVariants[playerArc] || event.defaultNarrative;
      
      return {
        ...event,
        description: this.injectPersonalizedElements(
          selectedVariant, 
          gameState
        ),
        weight: this.calculateNarrativeRelevance(event, playerArc, gameState)
      };
    });
  }
  
  /**
   * 根据玩家历史决策确定其"故事弧"类型
   * @param {Object} gameState - 游戏状态
   * @returns {string} 故事弧类型
   */
  static determinePlayerArc(gameState) {
    const stats = gameState.player.statistics || {};
    const choices = stats.significantChoices || {};
    
    // 分析玩家的关键决策模式
    if (choices.riskyChoices > choices.safeChoices * 2) {
      return 'RISK_TAKER';
    } else if (choices.safeChoices > choices.riskyChoices * 2) {
      return 'CAUTIOUS';
    } else if (choices.socialChoices > choices.selfishChoices) {
      return 'SOCIAL_CLIMBER';
    } else if (choices.marketManipulation > 5) {
      return 'MARKET_MANIPULATOR';
    }
    
    return 'BALANCED';
  }
  
  /**
   * 注入个性化叙事元素
   * @param {string} narrativeTemplate - 叙事模板
   * @param {Object} gameState - 游戏状态
   * @returns {string} 处理后的叙事内容
   */
  static injectPersonalizedElements(narrativeTemplate, gameState) {
    // 替换玩家相关的变量
    let processed = narrativeTemplate
      .replace(/{playerName}/g, gameState.player.name)
      .replace(/{playerMoney}/g, gameState.player.money)
      .replace(/{currentWeek}/g, gameState.currentWeek);
    
    // 替换更复杂的动态内容
    processed = processed.replace(/{playerReputation}/g, 
      this.generateReputationDescription(gameState.player.reputation));
    
    processed = processed.replace(/{marketCondition}/g,
      this.generateMarketDescription(gameState.market));
    
    return processed;
  }
}
```

### 8.7 情绪与体验曲线管理

实现体验曲线管理系统，控制游戏事件的情绪起伏，避免玩家体验过于平淡或过于紧张。

```javascript
// src/core/services/experienceCurveManager.js
export class ExperienceCurveManager {
  /**
   * 分析当前游戏紧张度
   * @param {Object} gameState - 游戏状态
   * @returns {Object} 紧张度分析结果
   */
  static analyzeCurrentGameTension(gameState) {
    const recentEvents = gameState.eventHistory.slice(-10);
    let tensionScore = 0;
    
    // 计算当前游戏"紧张度"
    recentEvents.forEach((event, index) => {
      const recency = 1 - (index / 10); // 越近的事件权重越高
      const eventTension = EVENT_TENSION_VALUES[event.id] || 0;
      tensionScore += eventTension * recency;
    });
    
    return {
      tensionLevel: Math.min(1, Math.max(0, tensionScore / 5)),
      needsRelief: tensionScore > 3.5,
      needsTension: tensionScore < 0.8,
      suggestedNextEventType: tensionScore > 3 ? 'RELIEF' : 'CHALLENGE'
    };
  }
  
  /**
   * 为体验曲线选择合适的事件
   * @param {Array} availableEvents - 可用事件列表
   * @param {Object} gameState - 游戏状态
   * @returns {Array} 经过排序的事件列表
   */
  static selectEventForExperienceCurve(availableEvents, gameState) {
    const gameCurve = this.analyzeCurrentGameTension(gameState);
    const playerFatigue = this.calculateEventTypeFatigue(gameState);
    
    // 根据当前体验曲线需求筛选合适的事件
    return availableEvents
      .filter(event => {
        // 避免重复类型事件导致疲劳
        if (playerFatigue[event.type] > 0.7) return false;
        
        // 根据当前紧张度选择适合的事件类型
        if (gameCurve.needsRelief && event.tensionImpact > 0.3) return false;
        if (gameCurve.needsTension && event.tensionImpact < 0) return false;
        
        return true;
      })
      .sort((a, b) => {
        // 综合考虑事件的权重和对体验曲线的贡献
        const aScore = a.weight * (1 - playerFatigue[a.type]) * 
                      this.calculateCurveContribution(a, gameCurve);
        const bScore = b.weight * (1 - playerFatigue[b.type]) * 
                      this.calculateCurveContribution(b, gameCurve);
        return bScore - aScore;
      });
  }
  
  /**
   * 计算事件类型疲劳度
   * @param {Object} gameState - 游戏状态
   * @returns {Object} 各事件类型的疲劳度
   */
  static calculateEventTypeFatigue(gameState) {
    const recentEvents = gameState.eventHistory.slice(-20);
    const fatigue = {};
    
    // 统计各类型事件的近期出现频率
    recentEvents.forEach((event, index) => {
      const recency = 1 - (index / 20); // 越近的事件疲劳影响越大
      fatigue[event.type] = (fatigue[event.type] || 0) + recency;
    });
    
    // 标准化疲劳值到0-1范围
    Object.keys(fatigue).forEach(key => {
      fatigue[key] = Math.min(1, fatigue[key] / 3);
    });
    
    return fatigue;
  }
}
```

### 8.8 多维事件标签系统

设计多维标签系统，为事件添加多方面的属性标签，便于系统更精确地筛选和匹配事件。

```javascript
// src/core/models/eventTagSystem.js
export class EventTagSystem {
  /**
   * 定义事件标签体系
   * @returns {Object} 标签分类系统
   */
  static defineEventTags() {
    return {
      // 情感标签
      emotions: [
        'EXCITEMENT', 'TENSION', 'RELIEF', 'SURPRISE', 
        'ACHIEVEMENT', 'DISAPPOINTMENT', 'HOPE'
      ],
      
      // 游戏机制标签
      mechanics: [
        'MARKET_INFLUENCE', 'RESOURCE_GAIN', 'RESOURCE_LOSS', 
        'RISK_REWARD', 'DECISION_POINT', 'KNOWLEDGE_GAIN'
      ],
      
      // 叙事标签
      narrative: [
        'MAIN_STORY', 'SIDE_STORY', 'CHARACTER_DEVELOPMENT',
        'WORLD_BUILDING', 'FORESHADOWING', 'REVELATION'
      ],
      
      // 难度标签
      difficulty: [
        'EASY', 'MEDIUM', 'HARD', 'STRATEGIC', 'TACTICAL'
      ]
    };
  }
  
  /**
   * 创建带标签的事件
   * @param {Object} eventData - 事件数据
   * @param {Object} tags - 标签对象
   * @returns {Object} 带标签的事件对象
   */
  static createEventWithTags(eventData, tags) {
    return {
      ...eventData,
      tags: tags
    };
  }
  
  /**
   * 根据标签查找事件
   * @param {Array} events - 事件列表
   * @param {Array} requiredTags - 必需的标签
   * @param {Array} excludedTags - 排除的标签
   * @returns {Array} 匹配的事件列表
   */
  static findEventsByTags(events, requiredTags, excludedTags = []) {
    return events.filter(event => {
      // 必须包含所有requiredTags
      const hasAllRequired = requiredTags.every(tag => 
        (event.tags || []).includes(tag)
      );
      
      // 不能包含任何excludedTags
      const hasNoExcluded = excludedTags.every(tag => 
        !(event.tags || []).includes(tag)
      );
      
      return hasAllRequired && hasNoExcluded;
    });
  }
  
  /**
   * 分析事件标签覆盖度
   * @param {Array} events - 事件列表
   * @returns {Object} 标签覆盖分析结果
   */
  static analyzeTagCoverage(events) {
    const allTags = this.defineEventTags();
    const coverage = {};
    const flattenedTags = [];
    
    // 扁平化所有标签
    Object.values(allTags).forEach(category => {
      category.forEach(tag => flattenedTags.push(tag));
    });
    
    // 统计每个标签的覆盖情况
    flattenedTags.forEach(tag => {
      coverage[tag] = events.filter(e => 
        (e.tags || []).includes(tag)
      ).length;
    });
    
    return {
      coverage,
      totalEvents: events.length,
      averageTagsPerEvent: events.reduce((acc, e) => acc + (e.tags?.length || 0), 0) / events.length,
      gapAnalysis: this.identifyTagGaps(coverage, events.length)
    };
  }
}
```

通过以上系统的进一步完善，事件系统将具有更好的:
- 长期反馈机制
- 动态平衡能力
- 个性化适应
- 复杂条件支持
- 可测试性
- 叙事深度
- 体验曲线控制
- 内容分类能力

这些改进将使游戏事件系统更加丰富、平衡，并能提供更个性化的游戏体验。 
